# Oracle-DuckDB 동기화 문제 분석 보고서

## 1. 개요
Streamlit 기반의 대시보드에서 "테스트 동기화 실행" 시 웹 페이지가 멈추고(Freezing), 로그 상에서 동기화 작업이 비정상적으로 반복 실행되는 현상에 대한 원인 분석 결과입니다.

## 2. 웹 페이지 Freezing (멈춤) 현상 원인
Streamlit 프레임워크의 구조적 특성과 긴 처리 시간이 충돌하여 발생합니다.

*   **메인 스레드 점유 (Blocking):** Streamlit은 기본적으로 단일 스레드(Single Thread)로 동작합니다. `sync_engine.test_sync()` 함수가 호출되면 동기화가 끝날 때까지 해당 스레드를 완전히 점유합니다.
*   **UI 응답 불가:** 동기화 로직이 실행되는 동안 서버는 브라우저의 다른 요청(화면 갱신 등)에 응답할 수 없게 되어, 사용자 입장에서는 화면이 멈춘 것처럼 보입니다.
*   **Oracle 쿼리 지연:** 특히 `SCHEMA.LARGE_TABLE` 테이블의 경우, 첫 번째 데이터를 가져오거나 쿼리를 준비하는 단계에서 상당한 시간이 소요되어 UI 차단 시간을 더욱 길게 만들고 있습니다.

## 3. 동기화 반복 실행 현상 원인
사용자가 버튼을 중복 클릭한 것이 아니라, **시스템에 의한 자동 재실행(Auto-Rerun)**이 주된 원인입니다.

*   **Heartbeat 타임아웃:** 긴 동기화 작업으로 인해 메인 스레드가 차단되면, 브라우저와 Streamlit 서버 간의 연결 상태 확인(Heartbeat) 패킷 처리가 지연됩니다.
*   **세션 자동 복구:** 브라우저는 서버 응답이 없으면 연결이 끊긴 것으로 간주하고 세션을 재연결하거나 페이지를 새로고침합니다. 이 과정에서 `app.py` 스크립트가 처음부터 다시 실행되면서 동기화 함수가 중복 호출됩니다.
*   **로그 증거:** 로그 상의 재실행 간격(약 10초, 60초 등)은 일반적인 네트워크 타임아웃 설정과 일치하며, 이는 사용자의 클릭 패턴이라기보다 시스템의 자동 동작일 가능성이 높습니다.
*   **파일 변경 감지:** 동기화 과정에서 생성되는 DuckDB 파일(`.db`)의 변경을 Streamlit이 소스 코드 변경으로 오인하여 앱을 재시작(Rerun)했을 가능성도 존재합니다.

## 4. 결론
현재의 문제는 코드의 논리적 오류(무한 루프 등)가 아니라, **장시간 실행되는 동기화 작업을 메인 UI 스레드에서 직접 처리하는 아키텍처 구조**에서 기인합니다. 

이로 인해 "UI 멈춤 -> 타임아웃 -> 앱 재실행 -> 동기화 중복 실행 -> 부하 가중"이라는 악순환이 발생하고 있습니다.
